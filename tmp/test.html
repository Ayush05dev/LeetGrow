<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
      
    <!-- Prism.js CDN for Syntax Highlighting -->
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.28.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.28.0/prism.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.28.0/components/prism-java.min.js"></script>  <!-- Include any other languages if needed -->



</head>
<body>
    <script>


function scrapeLeetCodeData() {
    const outputHTML = `
    <div class="output-box" style="padding:3px; color:yellow; margin-bottom:10px;" >
        <div style="font-weight:800">Question Title: </div>
      <div>Count Subarrays where maximum element comes atleast k times </div>
    </div>
  `;

  document.getElementById("output").innerHTML = outputHTML;
}





function generateTestCases() {
  const output = document.getElementById('output');
  
  // Create parent container (styled similar to "Thinking of Test Cases")
  const container = document.createElement('div');
  container.style.padding = '10px';
  container.style.border = '1px solid #ccc';
  container.style.borderRadius = '8px';

  // Add heading
  const heading = document.createElement('h3');
  heading.textContent = 'Test Cases';
  heading.style.marginBottom = '15px';
  heading.style.color = 'white';
  heading.style.fontFamily = 'Arial, sans-serif';
  container.appendChild(heading);

  // Create the wrapper div for test cases (with white background and border radius)
  const testCasesDiv = document.createElement('div');
  testCasesDiv.style.backgroundColor = 'white';
  testCasesDiv.style.borderRadius = '8px';
  testCasesDiv.style.padding = '15px';
  testCasesDiv.style.marginBottom = '15px';

  // Test case output
  const outputText = `[1,2,3,4]
[4,5,6,7]
[6,7,8,9]
`;

  const pre = document.createElement('pre');
  pre.textContent = outputText;
  pre.style.color = 'black';  // Make sure the text color is black for better visibility on white background
  testCasesDiv.appendChild(pre);

  // Append the testCasesDiv to the container
  container.appendChild(testCasesDiv);

  // Append the container to the output
  output.appendChild(container);
}



// function analyzeCode() {
//   const res = `
//   1.Issue Heading:jbknfknrkj vkjbvkjdfnk
//     detail issue :jkbfkkjnknkj jv uhvv kjbvkjdfnkj fkjbvfn ifbhdfnbkjk
//     solution: fkj dsbnjs jvbskjb fvnfvnfkjdnk fnnjf fn
//   2.Issue Heading:jbknfknrkj vkjbvkjdfnk
//     detail issue :jkbfkkjnknkj jv uhvv kjbvkjdfnkj fkjbvfn ifbhdfnbkjk
//     solution: fkj dsbnjs jvbskjb fvnfvnfkjdnk fnnjf fn
//  3.Issue Heading:jbknfknrkj vkjbvkjdfnk
//     detail issue :jkbfkkjnknkj jv uhvv kjbvkjdfnkj fkjbvfn ifbhdfnbkjk
//     solution: fkj dsbnjs jvbskjb fvnfvnfkjdnk fnnjf fn
//   `;

//   // Clear existing output
//   const output = document.getElementById('output');
//   output.innerHTML = '';

//   // Extract issues using regex
//   const issues = res.trim().split('\n').filter(line => line.trim() !== '');

//   issues.forEach((issueText, index) => {
//     // Create accordion container for each issue
//     const accordionItem = document.createElement('div');
//     accordionItem.style.marginBottom = '8px';
//     accordionItem.style.border = '1px solid #ccc';
//     accordionItem.style.borderRadius = '5px';
//     accordionItem.style.overflow = 'hidden';

//     // Create header button for issue
//     const header = document.createElement('button');
//     header.textContent = `Issue ${index + 1}: ${issueText.split(':')[0]}`;
//     header.style.width = '100%';
//     header.style.textAlign = 'left';
//     header.style.padding = '10px';
//     header.style.backgroundColor = 'blue';
//     header.style.color = 'white';
//     header.style.border = 'none';
//     header.style.cursor = 'pointer';
//     header.style.fontWeight = 'bold';

//     // Create content container for the solution
//     const content = document.createElement('div');
//     content.style.padding = '10px';
//     content.style.display = 'none';
//     content.style.backgroundColor = '#f4f4f4';
//     content.style.color = '#333';
//     content.textContent = `Solution for ${issueText.split(':')[0]}: Suggested solution here.`;

//     // Toggle display on click (show/hide issue and solution)
//     header.addEventListener('click', () => {
//       content.style.display = content.style.display === 'none' ? 'block' : 'none';
//     });

//     // Append header and content to accordion item
//     accordionItem.appendChild(header);
//     accordionItem.appendChild(content);

//     // Append the accordion item to the output
//     output.appendChild(accordionItem);
//   });
// }



// function analyzeCode() {
//   // Example response in JSON format
//   const res = [
//     {
//       issueHeading: 'Issue 1: Incorrect Indexing',
//       issueDetail: 'Detail issue: The array is being accessed with an incorrect index which leads to out-of-bounds errors.',
//       solution: 'Solution: Ensure proper index bounds check before accessing array elements.'
//     },
//     {
//       issueHeading: 'Issue 2: Memory Leak',
//       issueDetail: 'Detail issue: Objects are not being properly de-referenced, leading to memory leak.',
//       solution: 'Solution: Explicitly remove event listeners and close resources when done.'
//     },
//     {
//       issueHeading: 'Issue 3: API Response Timeout',
//       issueDetail: 'Detail issue: The API call takes too long to respond, causing timeouts.',
//       solution: 'Solution: Optimize the API endpoint and use asynchronous calls with proper error handling.'
//     }
//   ];

//   // Clear existing output
//   const output = document.getElementById('output');
//   output.innerHTML = '';

//   // Iterate through the issues in the JSON array
//   res.forEach((issue, index) => {
//     // Create accordion container for each issue
//     const accordionItem = document.createElement('div');
//     accordionItem.style.marginBottom = '8px';
//     accordionItem.style.border = '1px solid #ccc';
//     accordionItem.style.borderRadius = '5px';
//     accordionItem.style.overflow = 'hidden';

//     // Create header button for issue heading
//     const header = document.createElement('button');
//     header.textContent = `${issue.issueHeading}`;
//     header.style.width = '100%';
//     header.style.textAlign = 'left';
//     header.style.padding = '10px';
//     header.style.backgroundColor = 'blue';
//     header.style.color = 'white';
//     header.style.border = 'none';
//     header.style.cursor = 'pointer';
//     header.style.fontWeight = 'bold';

//     // Create content container for issue detail and solution
//     const content = document.createElement('div');
//     content.style.padding = '10px';
//     content.style.display = 'none';
//     content.style.backgroundColor = '#f4f4f4';
//     content.style.color = '#333';

//     // Issue Detail
//     const detail = document.createElement('p');
//     detail.textContent = issue.issueDetail;
//     content.appendChild(detail);

//     // Solution
//     const solution = document.createElement('p');
//     solution.textContent = issue.solution;
//     content.appendChild(solution);

//     // Toggle display on click (show/hide issue and solution)
//     header.addEventListener('click', () => {
//       content.style.display = content.style.display === 'none' ? 'block' : 'none';
//     });

//     // Append header and content to accordion item
//     accordionItem.appendChild(header);
//     accordionItem.appendChild(content);

//     // Append the accordion item to the output
//     output.appendChild(accordionItem);
//   });
// }




function analyzeCode() {
  const res = [
    {
      issueHeading: 'Issue 1: Incorrect Indexing',
      issueDetail: 'The array is being accessed with an incorrect index which leads to out-of-bounds errors.',
      solution: 'Ensure proper index bounds check before accessing array elements.'
    },
    {
      issueHeading: 'Issue 2: Memory Leak',
      issueDetail: 'Objects are not being properly de-referenced, leading to memory leak.',
      solution: 'Explicitly remove event listeners and close resources when done.'
    },
    {
      issueHeading: 'Issue 3: API Response Timeout',
      issueDetail: 'The API call takes too long to respond, causing timeouts.',
      solution: 'Optimize the API endpoint and use asynchronous calls with proper error handling.'
    }
  ];



  const output = document.getElementById('output');

      // Create parent container
  const container = document.createElement('div');
  container.style.padding = '10px';
  container.style.border = '1px solid #ccc';
  container.style.borderRadius = '8px';

 
  // Add heading
  const heading = document.createElement('h3');
  heading.textContent = 'Issues and Solutions';
  heading.style.marginBottom = '15px';
  heading.style.color = 'white';
  heading.style.fontFamily = 'Arial, sans-serif';
  container.appendChild(heading);





  res.forEach((issue, index) => {
    // Outer accordion for each issue
    const outerAccordion = document.createElement('div');
    outerAccordion.style.marginBottom = '12px';
    outerAccordion.style.border = '1px solid #ccc';
    outerAccordion.style.borderRadius = '6px';
    outerAccordion.style.overflow = 'hidden';

    const issueHeader = document.createElement('button');
    issueHeader.textContent = issue.issueHeading;
    issueHeader.style.width = '100%';
    issueHeader.style.textAlign = 'left';
    issueHeader.style.padding = '10px';
    issueHeader.style.backgroundColor = 'blue';
    issueHeader.style.color = 'white';
    issueHeader.style.border = 'none';
    issueHeader.style.cursor = 'pointer';
    issueHeader.style.fontWeight = 'bold';

    const issueContent = document.createElement('div');
    issueContent.style.display = 'none';
    issueContent.style.padding = '10px';
    issueContent.style.backgroundColor = '#f9f9f9';

    // Issue Detail
    const detailPara = document.createElement('p');
    detailPara.textContent = issue.issueDetail;
    detailPara.style.marginBottom = '10px';
    issueContent.appendChild(detailPara);

    // Inner accordion for solution
    const solutionAccordion = document.createElement('div');
    solutionAccordion.style.border = '1px solid #ddd';
    solutionAccordion.style.borderRadius = '4px';

    const solutionHeader = document.createElement('button');
    solutionHeader.textContent = 'Show Solution';
    solutionHeader.style.width = '100%';
    solutionHeader.style.textAlign = 'left';
    solutionHeader.style.padding = '8px';
    solutionHeader.style.backgroundColor = '#555';
    solutionHeader.style.color = 'white';
    solutionHeader.style.border = 'none';
    solutionHeader.style.cursor = 'pointer';
    solutionHeader.style.fontWeight = '600';

    const solutionContent = document.createElement('div');
    solutionContent.style.display = 'none';
    solutionContent.style.padding = '8px';
    solutionContent.style.backgroundColor = '#eee';
    solutionContent.style.color = '#333';
    solutionContent.textContent = issue.solution;

    // Toggle solution display
    solutionHeader.addEventListener('click', () => {
      solutionContent.style.display = solutionContent.style.display === 'none' ? 'block' : 'none';
    });

    solutionAccordion.appendChild(solutionHeader);
    solutionAccordion.appendChild(solutionContent);

    // Append inner solution accordion to issueContent
    issueContent.appendChild(solutionAccordion);

    // Toggle issue display
    issueHeader.addEventListener('click', () => {
      issueContent.style.display = issueContent.style.display === 'none' ? 'block' : 'none';
    });

    // Final assembly
    outerAccordion.appendChild(issueHeader);
    outerAccordion.appendChild(issueContent);
    container.appendChild(outerAccordion);
    output.appendChild(container);
  });
}




function approachHintGeneration() {
  const responseText = `
Hint 1: Try using a hash map to track the elements.
Hint 2: Think about two-pointer approach to optimize space.
Hint 3: Consider edge cases like empty arrays.
Hint 4: Maybe try a binary search if the array is sorted.
  `;

  // Clear existing output
  const output = document.getElementById('output');
//   output.innerHTML = '';

  // Create parent container
  const container = document.createElement('div');
  container.style.padding = '10px';
  container.style.border = '1px solid #ccc';
  container.style.borderRadius = '8px';

 
  // Add heading
  const heading = document.createElement('h3');
  heading.textContent = 'Hints';
  heading.style.marginBottom = '15px';
  heading.style.color = 'white';
  heading.style.fontFamily = 'Arial, sans-serif';
  container.appendChild(heading);

  // Extract hints using regex
  const hints = responseText.trim().split('\n').filter(line => line.trim() !== '');

  hints.forEach((hintText, index) => {
    // Create accordion container (individual hint box)
    const accordionItem = document.createElement('div');
    accordionItem.style.marginBottom = '8px';
    accordionItem.style.border = '1px solid #ccc';
    accordionItem.style.borderRadius = '5px';
    accordionItem.style.overflow = 'hidden';

    // Create header button
    const header = document.createElement('button');
    header.textContent = `Hint ${index + 1}`;
    header.style.width = '100%';
    header.style.textAlign = 'left';
    header.style.padding = '10px';
    header.style.backgroundColor = 'blue';
    header.style.color = 'white';
    header.style.border = 'none';
    header.style.cursor = 'pointer';
    header.style.fontWeight = 'bold';

    // Create content container
    const content = document.createElement('div');
    content.textContent = hintText.split(':').slice(1).join(':').trim();
    content.style.padding = '10px';
    content.style.display = 'none';
    content.style.backgroundColor = '#f4f4f4';
    content.style.color = '#333';

    // Toggle display on click
    header.addEventListener('click', () => {
      content.style.display = content.style.display === 'none' ? 'block' : 'none';
    });

    accordionItem.appendChild(header);
    accordionItem.appendChild(content);
    container.appendChild(accordionItem);
  });

  // Append the whole container to output
  output.appendChild(container);
}



function generateThinkTestCases() {
  const res = `1: If the list has no nodes (head is null), it should safely return no cycle.
2: A list with just one node that does not point to itself.
3: A list with one node that points to itself (i.e., head.next = head).
4: A standard linked list with multiple nodes and no cycle (last node points to null).
5: A cycle formed by connecting the last node back to the head.`;

  const output = document.getElementById('output');

  // Create parent container
  const container = document.createElement('div');
  container.style.padding = '10px';
  container.style.border = '1px solid #ccc';
  container.style.borderRadius = '8px';

    // Add heading
    const heading = document.createElement('h3');
  heading.textContent = 'Thinking of Test Cases';
  heading.style.marginBottom = '15px';
  heading.style.color = 'white';
  heading.style.fontFamily = 'Arial, sans-serif';
  container.appendChild(heading);

  // Split into individual test cases
  const cases = res.trim().split('\n');

  cases.forEach((testCase) => {
    const testCaseDiv = document.createElement('div');
    testCaseDiv.textContent = testCase;
    testCaseDiv.style.marginBottom = '10px';
    testCaseDiv.style.padding = '8px';
    testCaseDiv.style.backgroundColor = '#ffffff';
    testCaseDiv.style.border = '1px solid #ddd';
    testCaseDiv.style.borderRadius = '5px';
    testCaseDiv.style.boxShadow = '0 1px 3px rgba(0,0,0,0.05)';
    container.appendChild(testCaseDiv);
  });

  // Append container to output
  output.appendChild(container);
}




// function generateFullCode() {
//     const res = `
//     class Solution {
//     public:
//         long long countSubarrays(vector<int>& nums, int minK, int maxK) {
//             return 2;
//         }
//     };`;

//     // Create a div element for the code
//     const codeDiv = document.createElement('div');

//     // Set the background color of the code div to match the output background
//     codeDiv.style.backgroundColor = '#f4f4f4';  // Match the output container's background color
//     codeDiv.style.padding = '20px';  // Add some padding for better readability
//     codeDiv.style.borderRadius = '8px';  // Optional: to make it look more polished
//     codeDiv.style.fontFamily = 'monospace';  // Use monospace font for code
//     codeDiv.style.whiteSpace = 'pre-wrap';  // Make sure line breaks are preserved
//     codeDiv.style.overflowX = 'auto';  // Allow horizontal scrolling if the code is too long
//     codeDiv.style.maxWidth = '100%';  // Ensure the div doesn't go outside the screen width

//     // Set the text content to the code
//     codeDiv.textContent = res;


//     const copyButton = document.createElement('button');
// copyButton.textContent = 'Copy';
// copyButton.addEventListener('click', () => {
//   navigator.clipboard.writeText(res);  // Copies the code to clipboard
// });
// codeDiv.appendChild(copyButton);


//     // Find the output container (you can replace 'output' with the actual container's ID or class)
//     const outputContainer = document.getElementById('output'); 

//     // Append the codeDiv to the output container
//     outputContainer.appendChild(codeDiv);
// }




function generateFullCode() {
    const res = `
    class Solution {
    public:
        long long countSubarrays(vector<int>& nums, int minK, int maxK) {
            return 2;
        }
    };`;

    // Create a div element for the code
    const codeDiv = document.createElement('div');

    // Set the background color and styling for the code div
    //codeDiv.style.backgroundColor = '#f4f4f4';  // Match the output container's background color
    codeDiv.style.border = '1px solid #ccc';
    codeDiv.style.borderRadius = '8px';
    codeDiv.style.padding = '10px';  // Padding for readability
    codeDiv.style.borderRadius = '8px';  // Smooth rounded corners
    codeDiv.style.fontFamily = 'monospace';  // Monospace font for code
    codeDiv.style.whiteSpace = 'pre-wrap';  // Preserve line breaks
    codeDiv.style.overflowX = 'auto';  // Horizontal scrolling for overflowed code
    codeDiv.style.maxWidth = '100%';  // Prevent div from going beyond container


    // Add heading
  const heading = document.createElement('h3');
  heading.textContent = 'Code:';
  heading.style.marginBottom = '15px';
  heading.style.color = 'white';
  heading.style.fontFamily = 'Arial, sans-serif';
  codeDiv.appendChild(heading);



    // Apply Prism.js syntax highlighting by wrapping code with a <pre> and <code> block
    const codeBlock = document.createElement('pre');
    const codeElement = document.createElement('code');
    codeElement.className = 'language-java';  // Change language if needed
    codeElement.textContent = res;  // Set the code content
    codeBlock.appendChild(codeElement);  // Append <code> inside <pre>
    codeDiv.appendChild(codeBlock);  // Add <pre> block to the code div

    // Apply Prism.js highlighting
    Prism.highlightElement(codeElement);

    // Create the Copy button
    const copyButton = document.createElement('button');
    copyButton.textContent = 'Copy';
    copyButton.style.marginTop = '10px';  // Space between code and button
    copyButton.style.padding = '10px 15px';
    copyButton.style.border = 'none';
    copyButton.style.backgroundColor = '#4CAF50';  // Green color for button
    copyButton.style.color = 'white';
    copyButton.style.borderRadius = '5px';
    copyButton.style.cursor = 'pointer';
    copyButton.style.fontSize = '14px';

    // Add copy functionality to the button
    copyButton.addEventListener('click', () => {
        navigator.clipboard.writeText(res).then(() => {
            alert('Code copied to clipboard!');  // Show an alert once copied
        }).catch((err) => {
            console.error('Error copying code:', err);
        });
    });

    // Append the copy button below the code
    codeDiv.appendChild(copyButton);

    // Find the output container (you can replace 'output' with your actual container's ID or class)
    const outputContainer = document.getElementById('output'); 

    // Append the codeDiv to the output container
    outputContainer.appendChild(codeDiv);
}





let floatingWindow = document.createElement('div');
  floatingWindow.style.position = 'fixed';
  floatingWindow.style.top = '100px';
  floatingWindow.style.left = '100px';
  floatingWindow.style.width = '400px';
  floatingWindow.style.height = '500px';
  floatingWindow.style.background = 'black';
  floatingWindow.style.border = '2px solid black';
  floatingWindow.style.zIndex = 9999;
  floatingWindow.style.boxShadow = '0px 0px 10px rgba(0,0,0,0.5)';
  floatingWindow.style.padding = '0';
  floatingWindow.style.overflow = 'auto';
  floatingWindow.style.color = 'black';
  floatingWindow.style.resize = 'both';
  floatingWindow.style.minWidth = '300px';
  floatingWindow.style.minHeight = '300px';
  floatingWindow.style.maxWidth = '90vw';
  floatingWindow.style.maxHeight = '90vh';

  floatingWindow.innerHTML = `
  <div id="floatingHeader" style="cursor:move;padding:10px;background:#f0f0f0;border-bottom:1px solid #ccc;display:flex;justify-content:space-between;align-items:center; background-color:black;">
    <h3 style="margin:0 ;color: white;">LeetGrow Panel</h3>
    <button id="closeFloatingWindow" style="margin-left:auto;background:#e74c3c;color:white;border:none;padding:5px 10px;border-radius:4px;cursor:pointer;">X</button>
  </div>
  <div id="floatingContent" style="padding:2px; background-color:orange">
    <button class="floating-btn" id="scrapeBtn">Scrape</button>
    <button class="floating-btn" id="hintBtn">Hint</button>
    <button class="floating-btn" id="testcasesBtn">TestCases</button>
    <button class="floating-btn" id="thinkTestcasesBtn">Think TestCases</button>
    <button class="floating-btn" id="analyzeBtn">Analyze</button>
    <button class="floating-btn" id="completeCode">Analyze</button>
    
  </div>
  <div style="background-color:; padding:1px; margin-top:10px" id="output"  >
    
    </div>
`;


const style = document.createElement('style');
style.innerHTML = `
  .floating-btn {
    margin: 5px;
    padding: 8px 14px;
    background-color: #3498db;
    color: white;
    border: 1px solid #2980b9;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.2s ease;
  }
  .floating-btn:hover {
    background-color: #2980b9;
  }
`;
document.head.appendChild(style);



  document.body.appendChild(floatingWindow);

  // Close button functionality
  document.getElementById('closeFloatingWindow').addEventListener('click', () => {
    floatingWindow.remove();
    floatingWindow = null;
  });

  // Add your button logic here
  document.getElementById('scrapeBtn').addEventListener('click', scrapeLeetCodeData);
  document.getElementById('testcasesBtn').addEventListener('click', generateTestCases);
  document.getElementById('analyzeBtn').addEventListener('click', analyzeCode);
  document.getElementById('hintBtn').addEventListener('click', approachHintGeneration);
  document.getElementById('thinkTestcasesBtn').addEventListener('click', generateThinkTestCases);
  document.getElementById('completeCode').addEventListener('click', generateFullCode);

  // Draggable functionality
  const header = floatingWindow.querySelector('#floatingHeader');
  let isDragging = false, offsetX, offsetY;

  header.addEventListener('mousedown', function(e) {
    isDragging = true;
    offsetX = e.clientX - floatingWindow.getBoundingClientRect().left;
    offsetY = e.clientY - floatingWindow.getBoundingClientRect().top;
    document.body.style.userSelect = 'none';
  });

  document.addEventListener('mousemove', function(e) {
    if (isDragging) {
      floatingWindow.style.left = Math.min(Math.max(0, e.clientX - offsetX), window.innerWidth - 100) + 'px';
      floatingWindow.style.top = Math.min(Math.max(0, e.clientY - offsetY), window.innerHeight - 100) + 'px';
    }
  });

  document.addEventListener('mouseup', function() {
    isDragging = false;
    document.body.style.userSelect = 'auto';
  });

    </script>
</body>
</html>